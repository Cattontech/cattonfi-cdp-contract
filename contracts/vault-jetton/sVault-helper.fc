#pragma version >=0.4.4;
#include "constants.fc";
#include "utils.fc";

() send_transfer_message(slice dst, slice to_address, slice response_address, int jetton_amount, int total_fee, int mode) impure inline_ref {
    builder body = begin_cell()
                            .store_op(op::transfer)
                            .store_query_id(0)
                            .store_coins(jetton_amount)
                            .store_slice(to_address)
                            .store_slice(response_address)
                            .store_int(0, 1)
                            .store_coins(0)
                            .store_int(0, 1);
    send_raw_message(create_msg(TRUE, dst, null(), body, total_fee), mode);
}

int cal_mint_tJetton_amount(int from_amount, int total_sJetton_deposited, int total_tJetton) inline {
    if ((total_tJetton == 0) | (total_sJetton_deposited == 0) ) {
        return from_amount;
    }
    return from_amount * total_tJetton / total_sJetton_deposited;
}

int cal_withdraw_sJetton_amount(int from_amount, int total_sJetton_deposited, int total_tJetton) inline {
    if(total_tJetton == 0){
        return 0;
    }
    return from_amount * total_sJetton_deposited / total_tJetton;
}

(int, int) cal_reward_debt(int current_time, int reward_per_second, int acc_reward_per_share, int last_reward_time, int total_staked) inline {
    int time_reward = current_time - last_reward_time;
    int reward = time_reward * reward_per_second;

    if((reward > 0) & (total_staked > 0)) {
        acc_reward_per_share += reward * ACC_REWARD_PRECISION / total_staked;
    }
    return (acc_reward_per_share, current_time);
}
