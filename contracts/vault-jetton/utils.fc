#pragma version >=0.4.4;
#include "../imports/workchain.fc";
#include "constants.fc";
#include "op-codes.fc";

int math::pow(int x, int e) {
    if (e == 0) { return 1; }
    if (e == 1) { return x; }
    int p = math::pow(x, (e / 2));
    p = p * p;

    if ((e % 2) == 1) { p = p * x; }
    return p;
}

int forward_fee_of(cell msg) impure inline {
    slice cs = msg.begin_parse();
    ;; https://github.com/ton-blockchain/ton/blob/140320b0dbe0bdd9fd954b6633a3677acc75a8e6/crypto/vm/tonops.cpp#L1278
    var (c_cells, c_bits, _) = msg.compute_data_size((1 << 63) - 1);
    int cs_bits = cs.slice_bits();
    int forward_fee = get_forward_fee(MY_WORKCHAIN, c_bits - cs_bits, c_cells - 1);
    return forward_fee;
}

cell pack_sVault_wallet_data(slice owner_address, slice vault_address) inline {
    return  begin_cell()
                .store_bool(-1)
                .store_slice(owner_address)
                .store_slice(vault_address)
                .store_ref(begin_cell().store_coins(0).store_coins(0).store_coins(0).store_uint32(0).end_cell())
                .end_cell();
}

builder calculate_sVault_wallet_state_init(slice owner_address, slice sVault_address, cell sVault_wallet_code) inline {
    return begin_cell()
          .store_uint(0, 2)
          .store_dict(sVault_wallet_code)
          .store_dict(pack_sVault_wallet_data(owner_address, sVault_address))
          .store_uint(0, 1);
}

slice calculate_address(cell state_init) inline {
    return begin_cell().store_uint(4, 3)
                     .store_int(MY_WORKCHAIN, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

slice calculate_user_sVault_wallet_address(slice owner_address, slice sVault_address, cell sVault_wallet_code) inline {
    return calculate_address(calculate_sVault_wallet_state_init(owner_address, sVault_address, sVault_wallet_code).end_cell());
}

builder store_state_init(builder b, builder state_init) inline {
    return state_init.null?()
    ? b.store_uint(0, 1)
    : b.store_uint(2 + 0, 1 + 1).store_builder(state_init);
}

builder store_body(builder b, builder body) inline {
    return body.builder_bits() <= (513 - 265)
    ? b.store_uint(0, 1).store_builder(body)
    : b.store_maybe_ref(body.end_cell());
}

;; 6 + 267 + 124 + 1 + 4 + 4 + 64 + 32 + 2 + 5 + 1 + 513
cell build_msg(int bounceable?, slice dst, builder state_init, builder body, int coins) inline_ref {
    ;; extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) 
    ;;   = ExtraCurrencyCollection;
    ;; currencies$_ grams:Grams other:ExtraCurrencyCollection 
    ;;   = CurrencyCollection;
    ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    ;;   src:MsgAddress dest:MsgAddressInt
    ;;   value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    ;;   created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
    ;; message$_ {X:Type} info:CommonMsgInfoRelaxed
    ;;   init:(Maybe (Either StateInit ^StateInit))
    ;;   body:(Either X ^X) = MessageRelaxed X;
    cell msg = begin_cell()
    .store_uint(bounceable? ? 0x18 : 0x10, 6) ;; 011000 or 010000
    .store_slice(dst)
    .store_coins(coins)
    .store_uint(0, 1 + 4 + 4 + 64 + 32)
    .store_state_init(state_init)
    .store_body(body)
    .end_cell();
    return msg;
}

cell create_msg(int bounceable?, slice dst, builder state_init, builder body, int coins) impure inline_ref {
    return build_msg(bounceable?, dst, state_init, body, coins);
}

() send_mint_message(slice dst, slice to_address, int forward_fee, int jetton_amount, int total_fee, int mode) impure inline_ref {
    builder body = begin_cell()
                .store_op(op::mint)
                .store_query_id(0)
                .store_slice(to_address)
                .store_coins(forward_fee) 
                .store_ref(begin_cell()
                            .store_op(op::internal_transfer)
                            .store_query_id(0)
                            .store_coins(jetton_amount)
                            .store_slice(to_address)
                            .store_slice(to_address)
                            .store_coins(0)
                            .store_bool(FALSE)
                            .end_cell());
    send_raw_message(create_msg(TRUE, dst, null(), body, total_fee), mode);
}

() send_msg_excess_with_remainning_value(slice to_address) impure inline {
    builder excess = begin_cell().store_op(op::excesses).store_query_id(0);
    send_raw_message(create_msg(FALSE, to_address, null(), excess, 0), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
}