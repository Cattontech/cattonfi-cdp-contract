#pragma version >=0.4.4;
#include "../imports/workchain.fc";
#include "constants.fc";
#include "op-codes.fc";

int math::pow(int x, int e) {
    if (e == 0) { return 1; }
    if (e == 1) { return x; }
    int p = math::pow(x, (e / 2));
    p = p * p;

    if ((e % 2) == 1) { p = p * x; }
    return p;
}

cell pack_sVault_wallet_data(slice owner_address, slice vault_address) inline {
    return  begin_cell()
                .store_bool(-1)
                .store_slice(owner_address)
                .store_slice(vault_address)
                .store_ref(begin_cell().store_coins(0).store_coins(0).store_coins(0).store_uint32(0).end_cell())
                .end_cell();
}

builder calculate_sVault_wallet_state_init(slice owner_address, slice sVault_address, cell sVault_wallet_code) inline {
    return begin_cell()
          .store_uint(0, 2)
          .store_dict(sVault_wallet_code)
          .store_dict(pack_sVault_wallet_data(owner_address, sVault_address))
          .store_uint(0, 1);
}

slice calculate_address(cell state_init) inline {
    return begin_cell().store_uint(4, 3)
                     .store_int(MY_WORKCHAIN, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

slice calculate_user_sVault_wallet_address(slice owner_address, slice sVault_address, cell sVault_wallet_code) inline {
    return calculate_address(calculate_sVault_wallet_state_init(owner_address, sVault_address, sVault_wallet_code).end_cell());
}

builder store_state_init(builder b, builder state_init) inline {
    return state_init.null?()
    ? b.store_uint(0, 1)
    : b.store_uint(2 + 0, 1 + 1).store_builder(state_init);
}

builder store_body(builder b, builder body) inline {
    return body.builder_bits() <= (513 - 265)
    ? b.store_uint(0, 1).store_builder(body)
    : b.store_maybe_ref(body.end_cell());
}

cell build_msg(int bounceable?, slice dst, builder state_init, builder body, int coins) inline_ref {
    cell msg = begin_cell()
    .store_uint(bounceable? ? 0x18 : 0x10, 6) ;; 011000 or 010000
    .store_slice(dst)
    .store_coins(coins)
    .store_uint(0, 1 + 4 + 4 + 64 + 32)
    .store_state_init(state_init)
    .store_body(body)
    .end_cell();
    return msg;
}

cell create_msg(int bounceable?, slice dst, builder state_init, builder body, int coins) impure inline_ref {
    return build_msg(bounceable?, dst, state_init, body, coins);
}

() send_mint_message(slice dst, slice to_address, int forward_fee, int jetton_amount, int total_fee, int mode) impure inline_ref {
    builder body = begin_cell()
                .store_op(op::mint)
                .store_query_id(0)
                .store_slice(to_address)
                .store_coins(forward_fee) 
                .store_ref(begin_cell()
                            .store_op(op::internal_transfer)
                            .store_query_id(0)
                            .store_coins(jetton_amount)
                            .store_slice(to_address)
                            .store_slice(to_address)
                            .store_coins(0)
                            .store_bool(FALSE)
                            .end_cell());
    send_raw_message(create_msg(TRUE, dst, null(), body, total_fee), mode);
}

() send_msg_excess_with_remainning_value(slice to_address) impure inline {
    builder excess = begin_cell().store_op(op::excesses).store_query_id(0);
    send_raw_message(create_msg(FALSE, to_address, null(), excess, 0), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
}