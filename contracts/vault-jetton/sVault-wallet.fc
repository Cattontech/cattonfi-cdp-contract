
#pragma version >=0.4.4;
#include "../imports/errors.fc";
#include "op-codes.fc";
#include "utils.fc";
#include "sVault-wallet-storage.fc";

int cal_reward(int acc_reward_per_share) inline {
    return tJetton::balance * acc_reward_per_share / ACC_REWARD_PRECISION - tJetton::reward_debt;
}

int cal_keep_balance(int my_balance) inline {
    return my_balance >= VAULT_JETTON_MIN_STORAGE_FEE ? 0 : (VAULT_JETTON_MIN_STORAGE_FEE - my_balance);
}

() on_bounce(slice in_msg_body) impure inline {
    in_msg_body~skip_bounced_prefix();

    (int op, int query_id) = in_msg_body~load_op_and_query_id();
    load_data();

    if(op == op::execute_withdraw){
        int withdraw_amount = in_msg_body~load_coins();
        int acc_reward_per_share = tJetton::reward_debt * ACC_REWARD_PRECISION / tJetton::balance;
        tJetton::balance += withdraw_amount;
        tJetton::reward_debt = tJetton::balance * acc_reward_per_share / ACC_REWARD_PRECISION;
        send_msg_excess_with_remainning_value(data::owner_address);
        save_data();
    }
}

() is_lock() impure inline {
    throw_unless(error::not_open, data::status);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int msg_flags = cs~load_msg_flags();
    if (is_bounced(msg_flags)) {
        on_bounce(in_msg_body);
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    (int op, int query_id) = in_msg_body~load_op_and_query_id();
    load_data();

    if(op == op::open) {
        throw_unless(error::invalid_sender, equal_slices(data::sVault_address, sender_address));
        data::status = data::status ? FALSE : TRUE;
        save_data();
        return();
    }

    is_lock();

    if(equal_slices(data::sVault_address, sender_address)) {
        if(op == op::request_stake){
            raw_reserve(cal_keep_balance(my_balance), RESERVE_REGULAR);
            int stake_amount = in_msg_body~load_coins();
            slice response_address = in_msg_body~load_msg_addr();
            int acc_reward_per_share = in_msg_body~load_coins();
            int time_delay_withdraw = in_msg_body~load_uint32();
            in_msg_body.end_parse();
        
            int pending = cal_reward(acc_reward_per_share);
            throw_unless(error::invalid_reward, pending >= 0);

            tJetton::pending_reward += pending;
            tJetton::balance += stake_amount;
            tJetton::reward_debt = tJetton::balance * acc_reward_per_share / ACC_REWARD_PRECISION;
            tJetton::unlock_time = now() + time_delay_withdraw;
     
            builder excess = begin_cell().store_op(op::excesses).store_query_id(query_id);
            
            send_raw_message(create_msg(FALSE, response_address, null(), excess, 0), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
            save_data();
            return ();
        } elseif (op == op::request_mint_tJetton){
            raw_reserve(cal_keep_balance(my_balance), RESERVE_REGULAR);
            int mint_amount = in_msg_body~load_coins();
            int acc_reward_per_share = in_msg_body~load_coins();
            slice tJetton_address = in_msg_body~load_msg_addr();
            in_msg_body.end_parse();
            throw_unless(error::insufficient_collateral, tJetton::balance >= mint_amount);
        
            int pending = cal_reward(acc_reward_per_share);
            throw_unless(error::invalid_reward, pending >= 0);

            tJetton::pending_reward += pending;
            tJetton::balance -= mint_amount;
            tJetton::reward_debt = tJetton::balance * acc_reward_per_share / ACC_REWARD_PRECISION;

            send_mint_message(tJetton_address, data::owner_address, MINT_JETTON_FEE, mint_amount, 0, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
            save_data();
            return ();
        } elseif (op == op::request_withdraw){
            int withdraw_amount = in_msg_body~load_coins();
            int acc_reward_per_share = in_msg_body~load_coins();
            in_msg_body.end_parse();
            throw_unless(error::not_enough_collateral, withdraw_amount <= tJetton::balance);

            int pending = cal_reward(acc_reward_per_share);

            builder body_noti = begin_cell()
            .store_op(op::execute_withdraw)
            .store_query_id(query_id)
            .store_coins(withdraw_amount)
            .store_slice(data::owner_address)
            .store_bool(tJetton::unlock_time > now());

            send_raw_message(create_msg(true, data::sVault_address, null(), body_noti, 0), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);

            tJetton::pending_reward += pending;
            tJetton::balance -= withdraw_amount;
            tJetton::reward_debt = tJetton::balance * acc_reward_per_share / ACC_REWARD_PRECISION;
            save_data();
            return ();
        } elseif (op == op::set_data) {
            throw_unless(error::invalid_sender, equal_slices(data::sVault_address, sender_address));
            cell new_data = in_msg_body~load_ref();
            in_msg_body.end_parse();
            set_data(new_data);
            return();
        } elseif (op == op::claim) {
            int player_id = in_msg_body~load_uint64();
            int acc_reward_per_share = in_msg_body~load_coins();
            in_msg_body.end_parse();

            int pending = cal_reward(acc_reward_per_share);
            throw_unless(error::invalid_reward, pending >= 0);
        
            builder claim_body = begin_cell().store_op(op::claim_notification).store_query_id(query_id).store_coins(tJetton::pending_reward + pending).store_uint64(player_id).store_slice(data::owner_address);
            send_raw_message(create_msg(FALSE, data::sVault_address, null(), claim_body, 0), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
            tJetton::pending_reward = 0;
            tJetton::reward_debt = tJetton::balance * acc_reward_per_share / ACC_REWARD_PRECISION;
            save_data();
            return();
        } 
    }

    throw(error::invalid_op);
}

(int, int, int, int, int, slice, slice) get_wallet_data() method_id {
    load_data();
    return (data::status, tJetton::balance, tJetton::reward_debt, tJetton::pending_reward, tJetton::unlock_time, data::owner_address, data::sVault_address);
}

(int) get_flexible_data(int acc_reward_per_share) method_id {
    load_data();
    int pending_reward = cal_reward(acc_reward_per_share) + tJetton::pending_reward;
    return (pending_reward);
}